实现注解
注解原理
----------------------------------------------------------------------------------------------

进程 线程 携程
并发和并行
并发 多个程序交替在同一个CPU上被计算
并行 多个程序同时在多个CPU上被计算
 
阻塞 /非阻塞
阻塞 CPU不工作
非阻塞 CPU一直在工作
 
同步和异步
异步 发布一个任务,不等待这个任务的结果,就继续执行我的任务
同步 发布一个任务,等待获取这个任务的结果后才继续执行我的任务
同步阻塞
同步非阻塞
异步阻塞
异步非阻塞
进程
三状态

----------------------------------------------------------------------------------------------
协程和线程的区别

进程拥有自己独立的堆和栈，既不共享堆，亦不共享栈，进程由操作系统调度。

线程拥有自己独立的栈和共享的堆，共享堆，不共享栈，线程亦由操作系统调度(标准线程是的)。
线程很多的时候 ，调度线程，切换上下文资源是要消耗 很多资源的，影响性能

协程和线程一样共享堆，不共享栈，协程由程序员在协程的代码里显示调度。


进程和其他两个的区别还是很明显的。
协程和线程的区别是：协程避免了无意义的调度，由此可以提高性能，
但也因此，程序员必须自己承担调度的责任，同时，协程也失去了标准线程使用多CPU的能力。

---------------------------------------------------------------------------------------------------
c10k ：
互联网的情况下，大量tcp ，进程开启过多造成的cpu 和内存的消耗，单机无法承受

解决方案：

io 多路复用
每个进程/线程同时处理 多个连接(I/O多路复用)

select方式：使用fd_set结构体告诉内核同时监控那些文件句柄，使用逐个排查方式去检查是否有文件句柄就绪或者超时。
            该方式有以下缺点：文件句柄数量是有上线的，逐个检查吞吐量低，每次调用都要重复初始化fd_set。

poll方式： 该方式主要解决了select方式的2个缺点，文件句柄上限问题(链表方式存储)以及重复初始化问题(不同字段标注关注事件
           和发生事件)，但是逐个去检查文件句柄是否就绪的问题仍然没有解决。
epoll方式：该方式可以说是C10K问题的killer，他不去轮询监听所有文件句柄是否已经就绪。
           epoll只对发生变化的文件句柄感兴趣。其工作机制是，使用"事件"的就绪通知方式，通过epoll_ctl注册文件描述符fd，一旦该fd就绪，内核就会采用类似callback的回调机制来激活该fd, epoll_wait便可以收到通知, 并通知应用程序。而且epoll使用一个文件描述符管理多个描述符,将用户进程的文件描述符的事件存放到内核的一个事件表中, 这样数据只需要从内核缓存空间拷贝一次到用户进程地址空间。而且epoll是通过内核与用户空间共享内存方式来实现事件就绪消息传递的，其效率非常高。但是epoll是依赖系统的(Linux)。

异步I/O以及Windows，该方式在windows上支持很好，这里就不具体介绍啦。

----------------------------------------------------------------------------------------------------










